# /etc/nginx/nginx.conf

user nginx;

# vCPU=2なので auto のままでOK（cgroup/CPUセットにも追従）
worker_processes auto;

# systemd LimitNOFILE=1048576 をプロセスへ明示的に反映
worker_rlimit_nofile 1048576;

events {
    # 2 workers × 16384 ≒ 32768 同時接続の理論枠（FD, keepalive, upstreamで調整）
    worker_connections 16384;
    use epoll;
    multi_accept on;
    # 同時acceptでの競合緩和（スパイク時の安定化）
    accept_mutex on;
}

http {
    include mime.types;
    default_type application/octet-stream;

    # グローバルではproxy中心想定なので従来通りoff（直配信ロケーションで上書き）
    sendfile off;

    # バッファ類（現状維持：負荷試験前提のサイズ）
    client_body_buffer_size 256k;
    client_max_body_size 10m;
    client_header_buffer_size 2k;
    large_client_header_buffers 4 8k;

    # 静的ファイル向けFDキャッシュ（直配信のヒット率に寄与）
    open_file_cache max=20000 inactive=60s;
    open_file_cache_valid 120s;
    open_file_cache_min_uses 2;
    open_file_cache_errors on;

    # keepaliveは待機FDを消費するため短めに（スループット寄り）
    keepalive_timeout 15;
    keepalive_requests 10000;
    send_timeout 60;
    reset_timedout_connection on;

    # ログ抑制
    access_log off;
    error_log /var/log/nginx/error.log warn;

    # 圧縮はCPU節約のためoff（HTTP/2とTLS再利用で体感は維持）
    gzip off;

    # upstreamのkeepaliveを有効化（FD節約＆レイテンシ低減）
    upstream frontend {
        server frontend:3000;
        keepalive 128;
    }

    upstream backend {
        server backend:8080;
        keepalive 128;
    }

    upstream jaeger {
        server jaeger:16686;
        keepalive 32;
    }

    server {
        # HTTP/2とaccept分散（reuseport）を有効化
        listen 443 ssl http2 reuseport backlog=4096;

        ssl_certificate /da/tls/fullchain.pem;
        ssl_certificate_key /da/tls/privkey.pem;

        # TLSをモダン寄りに最適化（CPU効率の良いGCM系を優先）
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers on;
        ssl_session_cache shared:SSL:50m;
        ssl_session_timeout 1h;

        location /jaeger/ {
            proxy_pass         http://jaeger;
            proxy_set_header   Host $host;
            proxy_set_header   X-Real-IP $remote_addr;
            proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header   X-Forwarded-Proto $scheme;
            proxy_http_version 1.1;
            proxy_set_header   Connection "";
        }

        # 画像の直配信：sendfile有効化でカーネルバイパスI/Oを活用
        location = /api/v1/image {
            if ($arg_path = "")       { return 400 "画像パスが指定されていません\n"; }
            if ($arg_path ~ "\.\.")   { return 400 "無効なパスです\n"; }
            if ($arg_path ~ "^/")     { return 400 "無効なパスです\n"; }

            root /;
            try_files /app/images/$arg_path =404;

            # 直配信はsendfileをon（多数小さめファイル向き）
            sendfile on;
            tcp_nodelay on;

            access_log off;

            expires 1y;
            add_header Cache-Control "public, immutable";
        }

        location / {
            proxy_pass http://frontend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            proxy_buffering on;
            proxy_buffer_size 16k;
            proxy_buffers 32 16k;
            proxy_busy_buffers_size 32k;
            proxy_temp_file_write_size 32k;

            proxy_connect_timeout 30s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;

            proxy_http_version 1.1;
            proxy_set_header Connection "";
        }

        location /api/ {
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            proxy_buffering on;
            proxy_buffer_size 16k;
            proxy_buffers 32 16k;
            proxy_busy_buffers_size 32k;
            proxy_temp_file_write_size 32k;

            proxy_connect_timeout 30s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;

            proxy_http_version 1.1;
            proxy_set_header Connection "";
        }
    }

    server {
        listen 80 reuseport backlog=4096;
        return 301 https://$host$request_uri;
    }
}
